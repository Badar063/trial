import streamlit as st
import pandas as pd
import numpy as np
from PIL import Image
import os

# --- Configuration and Data Loading ---
RESULTS_FILE = 'archnet_results.csv'
VISUALIZATION_FILE = 'performance_comparison.png'

# Placeholder for ArchNetAdvisor class logic (Simplified for Streamlit deployment)
class StreamlitArchNetAdvisor:
    def __init__(self, performance_data):
        self.performance_data = performance_data
        # NOTE: The full scoring logic from your original code is maintained here for scenarios
    
    def recommend_model(self, scenario, top_k=3):
        df = self.performance_data.copy()
        
        # --- SCORING LOGIC FROM ORIGINAL CODE ---
        if scenario == 'accuracy':
            df['score'] = df['accuracy'] * 0.7 + df['f1_score'] * 0.3
        elif scenario == 'speed':
            df['score'] = (1/df['inference_time']) * 0.6 + (1/df['model_size_mb']) * 0.4
        elif scenario == 'efficiency':
            df['score'] = (1/df['model_size_mb']) * 0.6 + (1/df['inference_time']) * 0.4
        else:  # balanced
            df['score'] = (df['accuracy'] * 0.4 + df['f1_score'] * 0.3 + 
                           (1/df['inference_time']) * 0.15 + (1/df['model_size_mb']) * 0.15)
        
        return df.nlargest(top_k, 'score')

    def generate_reasoning(self, architecture, scenario):
        # NOTE: This uses the detailed reasoning structure from your original code.
        reasoning_map = {
            'EfficientNetB0': "Achieves state-of-the-art F1-score through compound scaling, balancing performance and size.",
            'ResNet50': "Deep residual learning provides high diagnostic accuracy, a safe choice for most clinical apps.",
            'MobileNetV2': "Extremely lightweight and fast; ideal for real-time mobile deployment or resource-limited edge devices.",
            'DenseNet121': "Parameter-efficient due to feature reuse, giving strong accuracy with efficient memory usage.",
            'VGG16': "Reliable baseline, but its larger size makes it less competitive for efficiency.",
        }
        return reasoning_map.get(architecture, "Good performance for medical imaging tasks.")

@st.cache_data
def load_results():
    """Load pre-computed results."""
    if os.path.exists(RESULTS_FILE):
        df_raw = pd.read_csv(RESULTS_FILE)
        # Prepare a clean DF for display
        df_display = df_raw.copy()
        df_display['Accuracy'] = (df_display['accuracy'] * 100).round(2).astype(str) + '%'
        df_display['F1 Score'] = df_display['f1_score'].round(3)
        df_display['Inference Time (s)'] = df_display['inference_time'].round(4).astype(str) + 's'
        df_display['Model Size (MB)'] = df_display['model_size_mb'].round(1)
        df_display = df_display.rename(columns={'architecture': 'Architecture'})
        return df_raw, df_display
    else:
        st.error(f"‚ö†Ô∏è **Deployment Error:** Results file '{RESULTS_FILE}' not found. Please run your core Python script first to generate the data!")
        return pd.DataFrame(), pd.DataFrame()

# Load Data
df_raw, results_df = load_results()
advisor = StreamlitArchNetAdvisor(df_raw)


# --- Streamlit Layout ---
st.set_page_config(layout="wide", page_title="ArchNet: CNN Performance Atlas")

st.title("üöó ArchNet: The CNN Performance Atlas")
st.markdown("### A Systematic Benchmark of Deep Architectures for Medical Imaging (50-Image Study)")

st.sidebar.header("Project Info")
st.sidebar.markdown("""
**Objective:** Provide evidence-based model recommendations for Chest X-ray analysis, focusing on the trade-off between **Diagnostic Power** and **Operational Efficiency**.
""")
st.sidebar.image("https://img.freepik.com/free-vector/x-ray-illustration-design_23-2148560822.jpg?w=740", caption="Benchmarking Chest X-rays", use_column_width=True) # 

#[Image of a chest x-ray illustration]


# --- 1. Performance Atlas Tab ---
tab1, tab2 = st.tabs(["üìã Performance Atlas", "ü§ñ ArchNet Advisor"])

with tab1:
    st.header("The Fair Race Results")
    st.markdown("This table summarizes the core metrics of the **5 architectures** evaluated under identical transfer learning conditions.")
    
    if not results_df.empty:
        st.dataframe(results_df[['Architecture', 'Accuracy', 'F1 Score', 'Inference Time (s)', 'Model Size (MB)', 'parameters']], 
                     use_container_width=True, hide_index=True)
        
        st.subheader("Visualized Trade-offs")
        
        if os.path.exists(VISUALIZATION_FILE):
            st.image(VISUALIZATION_FILE, caption='Comprehensive Performance Visualization (Generated by your code)', use_column_width=True)
        else:
            st.warning(f"Visualization plot '{VISUALIZATION_FILE}' not found. Please run the core script to generate it.")
        
        col_summary_1, col_summary_2, col_summary_3 = st.columns(3)
        
        # Get Key Findings
        best_accuracy = results_df.loc[results_df['Accuracy'].astype(str).str.strip('%').astype(float).idxmax()]
        best_speed = results_df.loc[results_df['Inference Time (s)'].str.strip('s').astype(float).idxmin()]
        
        with col_summary_1:
            st.metric("üèÜ Best F1-Score (Diagnostic Power)", best_accuracy['Architecture'], delta=best_accuracy['Accuracy'])
        with col_summary_2:
            st.metric("‚ö° Fastest Inference (Operational Speed)", best_speed['Architecture'], delta=f"{best_speed['Inference Time (s)']}")
        with col_summary_3:
            st.metric("üíæ Most Efficient (Smallest Size)", results_df.loc[results_df['Model Size (MB)'].idxmin()]['Architecture'], delta=f"{results_df['Model Size (MB)'].min()} MB")

# --- 2. ArchNet Advisor Tab ---
with tab2:
    st.header("ü§ñ ArchNet Advisor: Optimal Model Selector")
    st.markdown("The Advisor uses the empirical benchmark data to recommend the **best model** tailored to your **clinical or deployment priority**.")
    
    # User Input Form
    with st.form("advisor_form"):
        st.subheader("Define Your Priority")
        
        priority_options = {
            'accuracy': 'üéØ Maximum Accuracy (Critical care, low tolerance for error)',
            'speed': '‚ö° Maximum Speed (Real-time screening, high patient volume)',
            'efficiency': 'üí∞ Maximum Efficiency (Mobile/Edge deployment, low compute power)',
            'balanced': '‚öñÔ∏è Balanced Performance (All-around clinical use)'
        }
        
        selected_scenario_key = st.selectbox(
            "Select your primary focus for this AI application:",
            list(priority_options.keys()),
            format_func=lambda x: priority_options[x]
        )
        
        # Simulating image upload for context
        uploaded_file = st.file_uploader("Optional: Simulate Image Context (e.g., upload an X-ray)", type=['jpg', 'jpeg', 'png'])
        
        submitted = st.form_submit_button("Get Recommendation", type="primary")

    if submitted:
        st.subheader(f"Recommendations for: **{priority_options[selected_scenario_key].split('(')[0].strip()}**")
        
        if uploaded_file:
            st.image(uploaded_file, caption='Simulated Clinical Image Context', width=200)

        # Get recommendations using the Advisor class
        recommendations_raw = advisor.recommend_model(selected_scenario_key, top_k=3)
        
        for i, row in recommendations_raw.iterrows():
            rec_df_row = results_df[results_df['Architecture'] == row['architecture']].iloc[0]
            
            st.markdown(f"### üèÜ #{i+1}: {row['architecture']}")
            
            col_rec_1, col_rec_2 = st.columns([1, 2])
            
            with col_rec_1:
                st.metric("F1 Score", rec_df_row['F1 Score'])
                st.metric("Inference Time", rec_df_row['Inference Time (s)'])
                st.metric("Model Size", rec_df_row['Model Size (MB)'])
            
            with col_rec_2:
                reasoning = advisor.generate_reasoning(row['architecture'], selected_scenario_key)
                st.success("üí≠ **Advisor Reasoning:**")

                st.write(reasoning)
